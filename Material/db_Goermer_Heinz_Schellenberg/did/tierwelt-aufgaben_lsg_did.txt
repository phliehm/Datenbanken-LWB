Aufgaben mit Lösungen und kurzem methodisch-didaktischen Kommentar
(1)	Zeige alle Reptilienarten (vollständig) an!

RA: Unterarten

DRC: {UA_ID, Bezeichnung, Heimat, Lebensraum, Temperatur, Luftfeuchtigkeit, Groesse, Lebenserwartung, Ernaehrung, Besonderheiten | Unterarten (UA_ID, Bezeichnung, Heimat, Lebensraum, Temperatur, Luftfeuchtigkeit, Groesse, Lebenserwartung, Ernaehrung, Besonderheiten)}

SQL: SELECT * FROM Unterarten;

	Didaktischer Hintergrund: Erlernen der generellen Formulierung für Abfragen einzelner Tabellen

(2)	Zeige die Namen aller Tiere an!

RA: πName(Tiere)

DRC: {Name | Tiere (Name)}

SQL: SELECT Name FROM Tiere;

	Didaktischer Hintergrund: Einführung von Projektionen (dem Anzeigen einzelner, erwünschter Spalten) von Abfragen einzelner Tabellen

(3)	Zeige die Name aller weiblichen Tiere an!

RA: πName(σGeschlecht = 'W'(Tiere))

DRC: {Name | Tiere (Name,Geschlecht)∧ Geschlecht = 'W'}

SQL: SELECT Name FROM Tiere WHERE Geschlecht = 'W';

	Didaktischer Hintergrund: Einführung von Selektionen (dem Anzeigen einzelner Zeilen, die bestimmte Bedingungen erfüllen) von Abfragen einzelner Tabellen

(4)	Zeige alle Tiere mit ihren Informationen zur jeweiligen Tierart an!

RA: Tiere⋈Unterarten

DRC: {TI_ID, Name, Geschlecht, Zugangsdatum, Laenge, Gewicht, TR_ID, UA_ID, Bezeichnung, Heimat, Lebensraum, Temperatur, Luftfeuchtigkeit, Groesse, Lebenserwartung, Ernaehrung, Besonderheiten| Tiere (TI_ID, Name, UA_ID, Geschlecht, Zugangsdatum, Laenge, Gewicht, TR_ID) ∧ Unterarten (UA_ID, Bezeichnung, Heimat, Lebensraum, Temperatur, Luftfeuchtigkeit, Groesse, Lebenserwartung, Ernaehrung, Besonderheiten)}

SQL: SELECT * FROM Tiere NATURAL JOIN Unterarten;

	Didaktischer Hintergrund: Einführung von Natural Joins (der inhaltlichen Kombination) für Abfragen mehrerer Tabellen

(5)	Zeige die Namen aller Tiere an, die zu den „Bartagame“ gehören!

RA: πName(Tiere⋈(σBezeichnung = 'Bartagame'(Unterarten)))

DRC: {Name | Tiere (Name,UA_ID)∧Unterarten(UA_ID, Bezeichnung)∧ Bezeichnung = 'Bartagame'}

SQL: SELECT Name FROM Tiere NATURAL JOIN
(SELECT * FROM Unterarten WHERE Bezeichnung = 'Bartagame') AS xyz;

	Didaktischer Hintergrund: Kombination erlernter Operationen, hier Natural Join, Projektion und Selektion

(6)	Zeige die Namen aller Tiere an, welche in einem Terrarium des Typs „Wüste“ leben!

RA: πName(Tiere⋈Terrarien⋈(σBezeichnung = 'Wüste'(Habitattypen)))

DRC: {Name | Tiere (Name,TR_ID) ∧ Terrarien(TR_ID, HT_ID) ∧ Habitattypen(HT_ID, Bezeichnung) ∧ Bezeichnung = 'Wüste'}

SQL: SELECT Name FROM Tiere NATURAL JOIN Terrarien NATURAL JOIN
(SELECT * FROM Habitattypen WHERE Bezeichnung = 'Wüste') AS xyz;

	Didaktischer Hintergrund: Verkettung von Natural Joins für komplexere Abfragen

(7)	Zeige an, wann „Exo“ zunächst gefüttert werden muss!

RA: πFaelligkeit(Tierpflege ⋈ Arbeitsdienste ⋈ (σBezeichnung = 'Fütterung*'(Arbeitsdiensttypen)) ⋈
(σName = 'Exo'(Tiere)))

DRC: {Faelligkeit | Arbeitsdienste (Faelligkeit,AD_ID,AT_ID) ∧ Arbeitsdiensttypen(AT_ID,Bezeichnung) ∧ Tierpflege(AD_ID,TI_ID) ∧ Tiere(TI_ID,Name) ∧ Bezeichnung = 'Fütterung*' ∧Name = 'Exo'}

SQL: SELECT Faelligkeit FROM Tierpflege NATURAL JOIN Arbeitsdienste NATURAL JOIN
(SELECT AT_ID FROM Arbeitsdiensttypen WHERE Bezeichnung LIKE 'Fütterung%') AS x
NATURAL JOIN (SELECT TI_ID FROM Tiere WHERE Name = 'Exo') AS y;

[Anmerkung: PSQL liefert ab einer gewissen Anzahl von Attributen in den Ergebnismenge keine Antworten mehr. Daher wurden die Unterabfragen bei SQL auf die wesentlichen Attribute beschränkt, um eine funktionierende Abfrage zu erhalten.]

	Didaktischer Hintergrund: Weitere Verkomplizierung der inhaltlichen Komplexität; Einführung des „Like“-Operators

(8)	Zeige die ID, Namen und Beschreibungen aller Arbeitsdienste an, welche diese Woche fällig werden!

RA: πAD_ID, Bezeichnung, Beschreibung(σFaelligkeit(Woche) = Heute(Woche)(Arbeitsdienste)⋈ Arbeitsdiensttypen)

DRC: {AD_ID,Bezeichnung, Beschreibung | Arbeitsdiensttypen(Bezeichnung,Beschreibung,AT_ID) ∧ Arbeitsdienste(AT_ID,Faelligkeit) ∧ Faelligkeit(Woche) = Heute(Woche)}

SQL: SELECT AD_ID, Bezeichnung, Beschreibung FROM Arbeitsdiensttypen NATURAL JOIN
(SELECT * FROM Arbeitsdienste WHERE DATE_PART('week',Faelligkeit) =
DATE_PART('week', CURRENT_DATE)) AS xyz;

	Didaktischer Hintergrund: Arbeiten mit Datumsformaten

(9)	Zeige an, wann bei „Exo“ das nächste mal das Wasser gewechselt werden muss!

RA: πFaelligkeit(σName = Exo(Tiere)⋈Terrarien⋈Verbrauch⋈Arbeitsdienste⋈
σBezeichnung = 'Frischwasser'(Arbeitsdiensttypen)

DRC: {Faelligkeit | Arbeitsdienste(Faelligkeit,AT_ID,AD_ID)  ∧ Arbeitsdiensttypen(Bezeichnung,AT_ID) ∧ Verbrauch(AD_ID,TR_ID) ∧ Terrarien(TR_ID) ∧ Tiere(Name,TR_ID) ∧ Name = 'Exo' ∧ Bezeichnung = 'Frischwasser'}

SQL: SELECT Faelligkeit FROM (SELECT TR_ID FROM Tiere WHERE Name = 'Exo') AS x
NATURAL JOIN Terrarien NATURAL JOIN Verbrauch NATURAL JOIN Arbeitsdienste
NATURAL JOIN (SELECT AT_ID FROM Arbeitsdiensttypen
WHERE Bezeichnung = 'Frischwasser') AS y;

[Anmerkung: PSQL liefert ab einer gewissen Anzahl von Attributen in den Ergebnismenge keine Antworten mehr. Daher wurden die Unterabfragen bei SQL auf die wesentlichen Attribute beschränkt, um eine funktionierende Abfrage zu erhalten.]

	Didaktischer Hintergrund: Weitere Vertiefung und Anwendung bisher geübter Abfragen und komplexer werdender Zusammenhänge

(10)	Zeige alle Terrarien an, für welche es mindestens zwei aktuelle Arbeitsdienste gibt!

RA: Q1 = πTR_ID,AD_ID(Verbrauch) ∪ πTR_ID,AD_ID(Terrariumpflege)
Q2 = ρTR_ID2 ,A_ID2(Q2)
Q3 = Q1⋈TR_ID = TR_ID2∧AD_ID ≠ AD_ID2 Q2
Terrarien⋈πTR_ID(Q3)

DRC: Q1 = {TR_ID, AD_ID | Verbrauch(TR_ID,AD_ID ∨ Arbeitsdienste(TR_ID,AD_ID)}
Q2 = {TR_ID, AD_ID | Q1{TR_ID,AD_ID} ∧ Q1{TR_ID,AD_ID2} ∧AD_ID ≠ AD_ID2}
{TR_ID, Name, Beschreibung, Raumnummer, HT_ID, Hoehe, Tiefe, Breite, Breite_vorn |
Terrarien(TR_ID,Name,Beschreibung,Raumnummer,HT_ID,Hoehe,Tiefe,Breite,Breite_vorn)
∧ Q2(TR_ID)}

SQL: SELECT * FROM Terrarien NATURAL JOIN (SELECT TR_ID, COUNT(*) FROM
(SELECT TR_ID, AD_ID FROM Verbrauch 
UNION SELECT TR_ID,AD_ID FROM Terrariumpflege) AS x
GROUP BY TR_ID
HAVING COUNT(*) > 1) as y;

	Didaktischer Hintergrund: Einführung von Group By, Having und Count(); Nutzen von Umbenennung und Mehrfachnutzung von Zwischenergebnissen
